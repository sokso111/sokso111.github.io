<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用虚拟路径映射配置]]></title>
    <url>%2F2017%2F05%2F03%2F%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E8%B7%AF%E5%BE%84%E6%98%A0%E5%B0%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[背景：在使用UEditor的时候，用到了多图片上传和视频上传这两个组件（’insertimage’,”insertvideo”），如果不进行额外的配置，默认上传时会上传到项目的根目录下，其实这并不是一个好的做法，项目reload的时候，此前上传的图片和视频将会丢失。在自己写上传组件的时候，一般都会将图片上传到一个专门的磁盘路径下，而后再利用tomcat的虚拟路径映射配置，就能在项目中加载外部图片。查了下ue的配置项，并没有找到对应的虚拟路径配置的解决办法。于是发扬自己动手丰衣足食的精神，准备对源码下手。 ue的上传组件在ueditor-1.1.1.jar中，所以要先找到源码src，笔者用的是builder版本，所以源码直接在jsp的src文件夹下，建个java Application project，导入对应的src，目录结构如下： 对应的几个jar都是很常见的，笔者额外添加了一个commons-logging jar用来做日志的。先说下笔者的修改思路（修改开源代码的原则是不破坏原有的结构），ue上传生成的文件名增加UUID策略，config.json 增加两个配置项，用于控制是否启用虚拟路径配置 和 虚拟路径映射的实际物理目录，下面对着代码讲：先看下jsp/config.json的配置： 1234567891011121314151617181920212223242526/* 上传图片配置项 */ &quot;imageActionName&quot;: &quot;uploadimage&quot;, /* 执行上传图片的action名称 */ &quot;imageFieldName&quot;: &quot;upfile&quot;, /* 提交的图片表单名称 */ &quot;imageMaxSize&quot;: 2048000, /* 上传大小限制，单位B important */ &quot;imageAllowFiles&quot;: [&quot;.png&quot;, &quot;.jpg&quot;, &quot;.jpeg&quot;, &quot;.gif&quot;, &quot;.bmp&quot;], /* 上传图片格式显示 important */ &quot;imageCompressEnable&quot;: true, /* 是否压缩图片,默认是true important */ &quot;imageCompressBorder&quot;: 1600, /* 图片压缩最长边限制 important */ &quot;imageInsertAlign&quot;: &quot;none&quot;, /* 插入的图片浮动方式 */ &quot;imageUrlPrefix&quot;: &quot;http://192.168.0.177:8080/vsun&quot;, /* 图片访问路径前缀 TODO：上线部署时需要注意nginx环境对此配置项的影响 */ &quot;imageUsingVirtualPath&quot;: &quot;yes&quot;, /* 是否使用虚拟路径映射，设置为yes时开启 by will_awoke */ &quot;imageRealMappingPath&quot;: &quot;F:/dest/upload&quot;, /* 虚拟路径映射的实际物理目录，仅当imageUsingVirtualPath=yes时该配置有效 by will_awoke */ &quot;imagePathFormat&quot;: &quot;/media/image/&#123;uuid&#125;&quot;, /* 禁用虚拟路径映射配置（imageUsingVirtualPath=no）但tomcat开启虚拟映射时，该配置项不能对应虚拟路径 */ /* &quot;/ueditor/jsp/upload/image/&#123;yyyy&#125;&#123;mm&#125;&#123;dd&#125;/&#123;time&#125;&#123;rand:6&#125;&quot;,*/ /* 上传保存路径,可以自定义保存路径和文件名格式 */ /* &#123;uuid&#125; 推荐使用uuid by will_awoke */ /* 具请体看线上文档: fex.baidu.com/ueditor/#use-format_upload_filename */ /* 上传视频配置 */ &quot;videoActionName&quot;: &quot;uploadvideo&quot;, /* 执行上传视频的action名称 */ &quot;videoFieldName&quot;: &quot;upfile&quot;, /* 提交的视频表单名称 */ &quot;videoMaxSize&quot;: 102400000, /* 上传大小限制，单位B，默认100MB */ &quot;videoAllowFiles&quot;: [&quot;.mp4&quot;], /* 上传视频格式显示 此处为了浏览器的兼容性，视频格式要求为mp4 by will_awoke*/ &quot;videoUrlPrefix&quot;: &quot;http://localhost:8083/vsun&quot;, /* 视频访问路径前缀 */ &quot;videoUsingVirtualPath&quot;: &quot;yes&quot;, /* 是否使用虚拟路径映射，设置为yes时开启 by will_awoke */ &quot;videoRealMappingPath&quot;: &quot;F:/dest/upload&quot;, /* 虚拟路径映射的实际物理目录，仅当imageUsingVirtualPath=yes时该配置有效 by will_awoke */ &quot;videoPathFormat&quot;: &quot;/media/video/&#123;uuid&#125;&quot;, /* 上传保存路径,可以自定义保存路径和文件名格式 */ /* 暂时只实现上传图片和视频支持虚拟映射，其他请参照实现(需修改ueditor.jar源码) */ 以上传图片为例，这里增加了两个配置项：imageUsingVirtualPath 和 imageRealMappingPath，imageUsingVirtualPath 表示是否使用虚拟路径映射， 设置为no时表示关闭，设置为yes时开启；imageRealMappingPath 代表虚拟路径映射的实际物理目录，仅当imageUsingVirtualPath=yes时该配置有效。另外图片命名策略使用的是uuid。 uuid的策略增加到com.baidu.ueditor.PathFormat.java的getString方法 1234else if ( pattern.indexOf( PathFormat.UUID ) != -1 ) &#123; return UUIDGen.generate(); &#125; 123456public static String generate() &#123; UUID uuid = UUID.randomUUID(); return uuid.toString().replaceAll("-", ""); &#125; 修改配置管理类 com.baidu.ueditor.ConfigManager.java 的getConfig方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public Map&lt;String, Object&gt; getConfig ( int type ) &#123; Map&lt;String, Object&gt; conf = new HashMap&lt;String, Object&gt;(); String savePath = null; //是否使用虚拟路径映射 默认不使用 by will_awoke boolean virtualPath = false; switch ( type ) &#123; /* 暂时只实现上传图片和视频支持虚拟映射，其他请参照实现(需修改ueditor.jar源码) */ case ActionMap.UPLOAD_FILE: conf.put( "isBase64", "false" ); conf.put( "maxSize", this.jsonConfig.getLong( "fileMaxSize" ) ); conf.put( "allowFiles", this.getArray( "fileAllowFiles" ) ); conf.put( "fieldName", this.jsonConfig.getString( "fileFieldName" ) ); savePath = this.jsonConfig.getString( "filePathFormat" ); break; case ActionMap.UPLOAD_IMAGE: conf.put( "isBase64", "false" ); conf.put( "maxSize", this.jsonConfig.getLong( "imageMaxSize" ) ); conf.put( "allowFiles", this.getArray( "imageAllowFiles" ) ); conf.put( "fieldName", this.jsonConfig.getString( "imageFieldName" ) ); //for virtual path mapping String imagePathFormat = this.jsonConfig.getString("imagePathFormat"); String imageUsingVirtualPath = this.jsonConfig.getString("imageUsingVirtualPath"); if("yes".equalsIgnoreCase(imageUsingVirtualPath))&#123; String imageRealMappingPath = this.jsonConfig.getString("imageRealMappingPath"); savePath = imageRealMappingPath + imagePathFormat; virtualPath = true; conf.put( "realMappingPath", imageRealMappingPath);//put into conf map using key=realMappingPath log.debug("image real savePath(including PathFormat):" + savePath); &#125;else if("no".equalsIgnoreCase(imageUsingVirtualPath))&#123; log.debug("not virtual, using imagePathFormat as savePath"); savePath = imagePathFormat; &#125;else&#123; log.warn("invalid imageUsingVirtualPath in json.config:" + imageUsingVirtualPath+",it should be 'yes' or 'no'..."); &#125; //savePath = this.jsonConfig.getString( "imagePathFormat" ); break; case ActionMap.UPLOAD_VIDEO: conf.put( "maxSize", this.jsonConfig.getLong( "videoMaxSize" ) ); conf.put( "allowFiles", this.getArray( "videoAllowFiles" ) ); conf.put( "fieldName", this.jsonConfig.getString( "videoFieldName" ) ); //for virtual path mapping String videoPathFormat = this.jsonConfig.getString("videoPathFormat"); String videoUsingVirtualPath = this.jsonConfig.getString("videoUsingVirtualPath"); if("yes".equalsIgnoreCase(videoUsingVirtualPath))&#123; String videoRealMappingPath = this.jsonConfig.getString("videoRealMappingPath"); savePath = videoRealMappingPath + videoPathFormat; virtualPath = true; conf.put( "realMappingPath", videoRealMappingPath);//put into conf map using key=realMappingPath log.debug("video real savePath(including PathFormat):" + savePath); &#125;else if("no".equalsIgnoreCase(videoUsingVirtualPath))&#123; log.debug("not virtual, using videoPathFormat as savePath"); savePath = videoPathFormat; &#125;else&#123; log.warn("invalid videoUsingVirtualPath in json.config:" + videoUsingVirtualPath+",it should be 'yes' or 'no'..."); &#125; //savePath = this.jsonConfig.getString( "videoPathFormat" ); break; //其他略.... &#125; conf.put( "savePath", savePath ); conf.put( "rootPath", this.rootPath ); conf.put( "virtualPath", virtualPath );//add put return conf; &#125; 最后要修改上传类com.baidu.ueditor.upload.BinaryUploader save方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public static final State save(HttpServletRequest request, Map&lt;String, Object&gt; conf) &#123; FileItemStream fileStream = null; boolean isAjaxUpload = request.getHeader( "X_Requested_With" ) != null; if (!ServletFileUpload.isMultipartContent(request)) &#123; return new BaseState(false, AppInfo.NOT_MULTIPART_CONTENT); &#125; ServletFileUpload upload = new ServletFileUpload( new DiskFileItemFactory()); if ( isAjaxUpload ) &#123; upload.setHeaderEncoding( "UTF-8" ); &#125; try &#123; FileItemIterator iterator = upload.getItemIterator(request); while (iterator.hasNext()) &#123; fileStream = iterator.next(); if (!fileStream.isFormField()) break; fileStream = null; &#125; if (fileStream == null) &#123; return new BaseState(false, AppInfo.NOTFOUND_UPLOAD_DATA); &#125; String savePath = (String) conf.get("savePath"); String originFileName = fileStream.getName(); String suffix = FileType.getSuffixByFilename(originFileName); originFileName = originFileName.substring(0, originFileName.length() - suffix.length()); savePath = savePath + suffix; long maxSize = ((Long) conf.get("maxSize")).longValue(); if (!validType(suffix, (String[]) conf.get("allowFiles"))) &#123; return new BaseState(false, AppInfo.NOT_ALLOW_FILE_TYPE); &#125; //using PathFormat savePath = PathFormat.parse(savePath, originFileName); boolean virtualPath = (boolean)conf.get("virtualPath"); String physicalPath = (String) conf.get("rootPath") + savePath; //启用虚拟路径时，不再使用 rootPath if(virtualPath) &#123; //此时savePath已含有实际的映射物理路径 physicalPath = savePath;//no rootPath &#125; log.debug("file physicalPath:" + physicalPath); InputStream is = fileStream.openStream(); State storageState = StorageManager.saveFileByInputStream(is, physicalPath, maxSize); is.close(); if (storageState.isSuccess()) &#123; storageState.putInfo("url", PathFormat.format(savePath)); //启动虚拟路径时，返回ue的url将不再携带realMappingPath，否则ue无法正常加载对应的已上传的图片/视频等 if(virtualPath)&#123; String temp = (String) conf.get("realMappingPath"); storageState.putInfo("url", PathFormat.format(savePath.substring(temp.length()))); &#125; storageState.putInfo("type", suffix); storageState.putInfo("original", originFileName + suffix); &#125; return storageState; &#125; catch (FileUploadException e) &#123; log.error(e + " " + e.getMessage()); return new BaseState(false, AppInfo.PARSE_REQUEST_ERROR); &#125; catch (IOException e) &#123; log.error(e + " " + e.getMessage()); &#125; return new BaseState(false, AppInfo.IO_ERROR); &#125; 举个例子说明：“imageUsingVirtualPath”: “yes”“imageRealMappingPath”: “F:/dest/upload”“imageUrlPrefix”: “http://192.168.0.177:8080/vsun““imagePathFormat”: “/media/image/{uuid}” “videoUsingVirtualPath”: “yes”“videoRealMappingPath”: “F:/dest/upload”“videoUrlPrefix”: “http://192.168.0.177:8080/vsun““videoPathFormat”: “/media/video/{uuid}” tomcat server.xml中配置的虚拟映射为 ，正确配置后，图片会上传到f:/dest/upload/media/image/2f1ec7d9f441474aa47424c88899045b.jpg， 视频会上传到f:/dest/upload/media/video/3658d1a3b2cb4a17a4907ba46854e9ca.mp4。 在ue中对应的链接分别是：http://192.168.0.177:8080/vsun/media/image/2f1ec7d9f441474aa47424c88899045b.jpg， http://192.168.0.177:8080/vsun/media/video/3658d1a3b2cb4a17a4907ba46854e9ca.mp4，如果不出现404证明上述配置正确。]]></content>
      <tags>
        <tag>ueditor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ueditor图片上传配置]]></title>
    <url>%2F2017%2F05%2F03%2FUeditor%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[ueditor图片在线管理不能显示问题：它使用的是tomcat项目中的绝对路径： E:/apache-tomcat-6.0.44/apache-tomcat-6.0.44webapps/⋯⋯ 修改方法修改 dialogs–&gt;image–&gt;路径下的image.js文件 修改image.js文件中 在pushData: function (list) 方法中添加如下代码： var re = /([a-zA-Z]{1}\:.*webapps)/; var newUrl list[i].url.replace(re.exec(list[i].url)[1],&quot;&quot;); 将代码中的list[i].url替换为newUrl： 1img.setAttribute('src', urlPrefix + newUrl + (newUrl.indexOf('?') == -1 ? '?noCache=':'&amp;noCache=') +(+new Date()).toString(36) ); img.setAttribute('_src', urlPrefix + newUrl);]]></content>
      <tags>
        <tag>ueditor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown学习]]></title>
    <url>%2F2017%2F05%2F02%2FMarkDown%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[一， MarkDown语法的简要规则标题一级标题二级标题三级标题四级标题序列无序列表 1 2 3 有序列表 1 2 3 引用 这里是引用 图片和链接图片为：{ImgCap}{/ImgCap} 链接为： 插入链接baidu 插入图片 粗体与斜体这是斜体这是粗体 我经常去的几个网站Google、Leanote以及自己的博客Leanote 笔记是一个不错的网站。 Markdown: 轻量级文本标记语言，可以转换成html，pdf等格式（左侧有一个可见的冒号和四个不可见的空格） 代码块 2: 这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格） 代码块（左侧有八个不可见的空格） 包含代码区块的引用如果要放代码区块的话，该区块就需要缩进两次， 也就是8个空格或是2个制表符 代码var a="qwerhgbvds" console.log(123)]]></content>
      <categories>
        <category>MarkDwon</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat配置]]></title>
    <url>%2F2017%2F05%2F02%2FTomcat%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[#Tomcat配置1、直接把项目web文件夹放在webapps里。 2、在tomcat\conf\server.xml中的内部添加标签: docBase:项目路径，可以使用绝对路径或相对路径，相对路径是相对于 webappspath:访问项目的路径，如：http://127.0.0.1:8080/demo1 reloadable:是否自动加载新增或改变的class文件. debug属性与这个Engine关联的Logger记录的调试信息的详细程度。数字越大，输出越详细。如果没有指定，缺省为0。 也就是程序异常时写入日志文件里的详细程度。 3、第三种方式和第二种差不多，但是不是在Server.xml文件中添加Context标签，而是在 %tomcat_home%\conf\Catalina\localhost中添加一个XML文件， 如:demo1.xml，内容如下： &lt;?xml version=”1.0” encoding=”UTF-8”?&gt;\\ 只是缺少了path属性，如果你硬写个path=”demo2”的话，是没有用的，tomcat不明确的告诉你：“我不认得”， 这种方式服务器会使用xml文件的名字作为path属性的名字，SO访问地址为：http://localhost:8080/demo1 \ connectionTimeout指代http的超时时间，当客户端主动断开http链接时，tomcat可以在链接建立20000毫秒时断开。当服务端处理超过20000毫秒时也会主动断开链接。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可妮宝宝么么哒]]></title>
    <url>%2F2017%2F05%2F02%2F%E5%8F%AF%E5%A6%AE%E5%AE%9D%E5%AE%9D%E4%B9%88%E4%B9%88%E5%93%92%2F</url>
    <content type="text"></content>
  </entry>
</search>